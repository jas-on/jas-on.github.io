---
layout: post
title: Thoughts on 'How to be a great software developer'
---
[Original post](http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer) by Peter Nixey.

>I believe that your seniority and value as a programmer is measured not in what you know, it’s measured in what you put out.

At the bottom line, it’s about results and not potential; sure it’s great to be able to do great things, but doing them is actually better. Peter mentions a few canonical interview questions and belittles them as being able to solve them mean almost nothing when comes to moving a team forward. This is an issue with many interviewers today; they don’t ask enough questions which truly require experienced insight to be answered well.

>simplicity is far more easily attained by time spent working and refactoring than hours of pure thought.

Strokes of genius are great, but sometimes they come because of luck. Peter believes that a bottom-up approach is more effective than a top-down one in that one should build a tool as minimally as possible and then refactor it over and over again until it’s perfect rather than trying to 'get it right' the first time. This idea of a minimum viable product is very important in software development as it allows for more releases, more testing, and more customer satisfaction.

>Fuck Rockstars. Hire workhorses.

There are plenty of geniuses out there, as Peter points out, but some of them are lacking in team cooperation skills and their arrogance can belittle their image as a whole. What goes into a high performing team are hardworking people with discipline and perseverance. Consistency in being able to produce quality code is much more important than the ability to spin up a quick hack.

>learn your chosen stack inside out

It’s important to fully understand the technologies you use and what they can deliver because doing so can save a tremendous amount of time and pain. Reimplementing a feature that has already been well instated is one of the worst hits to productivity as a developer. The thing about software development is that half of what programmers do is build off of existing code bases to create even more complex things. Even though they don’t have to create any of the legacy features, the least they should do is learn what they are and how to correctly use them.

>Learn to detect the smell of bad code

Being able to differentiate bad code from good code is important in one’s ability to write good code. It makes sense because being able to understand what makes a piece of code bad requires one to know what the better alternative is. This ties in with writing readable code. Good code should be self documenting and the flow of logic should be clear. If it this isn’t the case, then refactoring or redesigning the program might be necessary. Ultimately, taking the time to do this will save a heck of a lot of pain and tears when you or another team comes back to dig up the code.

>technical debt is the best type of debt in the world because you don’t always have to pay it back

I don’t agree with Peter’s take on technical debt. I see his point in leveraging it in the beginning of a project to push functionality out quickly, and risking very little development time to do so because it may turn out that the feature wasn’t even needed or was replaced later on. However, I believe that there is a distinction between 'good enough' design and acquiring 'technical debt'. The former ensures a baseline integrity of the code’s quality being written while the latter doesn’t; when the 'exploratory phase' is over and the feature is still needed, it can be a lot harder to refactor the code and pay back the debt. Not building a feature correctly and reducing the damage can be remedied with shorter iterations and complete clarity when discussing user stories with the customer. It should never be an excuse to write 'scouting code' because of this fear.

>Make your team better

I think this quality is the most important one out of all of the ones necessary to be a good software developer. The first thing to realize is that great products are the result of many individual contributions by many people. Being a 'rockstar' programmer who can’t communicate with others is much worse in net productivity gain compared to being someone who can cooperate and help teammates. Helping other people with their problems can possibly allow them to make greater progress on their portions of the project than you on your own. From a wide perspective, this active attention to others, whether bouncing ideas off of them or boosting their morale, is a valuable aspect of team logistics.

>It’s not who you are on the inside that defines you

This ties back in with what Peter mentioned at the beginning of the article: it’s not about what you say you can do; it’s about what you do. I hold this statement dear to my heart because, as a result-oriented person, all I care about is the now and future, not the past.
